/**
 * eval(string)
 * desc:
 *    1、传入的参数是字符串，如果不是字符串将会被eval原封不动的返回, 可以执行传入的字符串（将传入的字符串作为脚本）
 *    2、对参数的执行（方式）:
 *      （1）如果参数是一个表达式，eval() 函数将执行表达式；
 *      （2） 如果参数是Javascript语句，eval()将执行 Javascript 语句
 *          注：（如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数）
 *      （3）解析JSON字符串
 *           注：使用eval来解析JSON格式字符串的时候，会将{}解析为代码块，而不是对象的字面量
 *               1.在JSON格式的字符串前面拼接上 “var o =”
 *               2.把JSON格式的字符串使用()括起来，就不会将{}解析为代码块，而是表达式
 * 作用域:
 *    eval()函数并不会创建一个新的作用域，并且它的作用域就是它所在的作用域，有时候需要将eval()函数的作用域设置为全局，
 *          当然可以将eval()在全局作用域中使用，这个时候可以用window.eval()的方式实现。
 * Function和eval有什么区别？
 *      共同点：都可以将字符串转化为js代码
 *      不同点：Function创建出来的函数并不会直接调用，只有当手动去调用创建出来的函数的时候才调用，eval把字符串转化为代码后，直接就执行了。
 * 
 * 缺点:
 *    1、代码的执行效率低下，你在eval中执行的全局变量，在js解释器执行的时候还需要查找在eval传入的字符串中是否有相同的变量
 *       这就会产生高代价去查找变量
 * 
 * */ 
eval("{b:2}");//声明一个对象。如果想返回此对象，则需要在对象外面再嵌套一层小括如下：eval("({b:2})");
// console.log(eval("({b:2})"));
// console.log('dd', eval(new String("2 + 2")), eval("2 + 2"));
// eval(new String("2 + 2")); // 返回了包含"2 + 2"的字符串对象
// eval("2 + 2");    